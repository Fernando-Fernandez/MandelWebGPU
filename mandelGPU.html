<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Mandelbrot WebGL</title>
<style>
  /* Fullscreen overlayed canvases allow WebGL rendering plus interaction layer */
  body { margin: 0; }
  canvas { position:absolute; left:0; top:0; display:block; }
  #glcanvas { width:100vw; height:100vh; z-index:0; }
  #overlay { width:100vw; height:100vh; z-index:1; }
</style>
</head>
<body>

<canvas id="glcanvas"></canvas>
<canvas id="overlay"></canvas>

<script>

// Fullscreen quad vertex shader; it simply emits clip-space corners.
const vertexShaderSrc = `
attribute vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
}`;

// Fragment shader performs the Mandelbrot iteration and colors by escape time.
const fragmentShaderSrc = `
precision highp float;
uniform vec2 u_center;
uniform vec2 u_resolution;
uniform vec2 u_zoom;
uniform float u_aspect;
uniform int u_maxIter;
uniform float u_colorScale;
uniform bool u_smoothColor;   // NEW toggle
uniform float u_paletteOffset;
//uniform bool u_logScale;      // NEW toggle

const int MAX_ITER = 2000;
const float PALETTE_SIZE = 14.0;

vec3 palette(float idx) {
    // Compact hard-coded palette approximates a classic rainbow gradient.
    float i = mod(idx, PALETTE_SIZE);
    if(i < 1.0) return vec3(0.5,0.5,0.5);
    if(i < 2.0) return vec3(0.0,0.0,0.0);
    if(i < 3.0) return vec3(0.6,0.4,0.2);
    if(i < 4.0) return vec3(1.0,0.0,0.0);
    if(i < 5.0) return vec3(1.0,0.5,0.0);
    if(i < 6.0) return vec3(1.0,1.0,0.0);
    if(i < 7.0) return vec3(0.0,1.0,0.0);
    if(i < 8.0) return vec3(0.5,1.0,0.83);
    if(i < 9.0) return vec3(0.0,1.0,1.0);
    if(i < 10.0) return vec3(0.0,0.0,1.0);
    if(i < 11.0) return vec3(0.0,0.0,0.5);
    if(i < 12.0) return vec3(0.5,0.0,0.5);
    if(i < 13.0) return vec3(1.0,0.0,1.0);
    return vec3(1.0,1.0,1.0);
}

void main() {
    // Normalize pixel coordinates and compensate for non-square screen aspect.
    vec2 uv = (gl_FragCoord.xy / u_resolution) - 0.5;
    uv.x *= u_aspect; // Keep the fractal square even when the screen is wide

    // Current complex plane coordinate: c = uv * zoom + center
    vec2 c = vec2(
        uv.x * u_zoom.x + u_center.x,
        uv.y * u_zoom.y + u_center.y
    );

    vec2 z = vec2(0.0); // Running z_n term
    float i = 0.0;
    bool escaped = false;

    for(int n = 0; n < MAX_ITER; n++) {
        if(n >= u_maxIter) break;

        // Classic Mandelbrot recurrence z = z^2 + c
        z = vec2(
            z.x*z.x - z.y*z.y + c.x,
            2.0*z.x*z.y + c.y
        );

        if(dot(z,z) > 4.0) {
            i = float(n);
            escaped = true;
            break;
        }
        i = float(n);
    }

    if(!escaped) {
        gl_FragColor = vec4(0.0,0.0,0.0,1.0);
        return;
    }

    float val = i;

    if(u_smoothColor) {
        // Apply fractional iteration count for smoother gradients.
        float mag = dot(z,z);
        val = val + 1.0 - log(log(mag)) / log(2.0); // fractional escape
    }

    //if(u_logScale) {
    //    val = log(val + 1.0); // log brightness scale
    //}

    // Cycle through the palette continuously using the animated offset.
    float scaled = val * u_colorScale + u_paletteOffset;
    gl_FragColor = vec4(palette(scaled),1.0);
}
`;

// Compile a shader stage and log GLSL errors in the console.
function compileShader(gl, type, source) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(s));
    return s;
}

// Link vertex + fragment shaders into a WebGL program.
function createProgram(gl, vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS))
        console.error(gl.getProgramInfoLog(p));
    return p;
}

// Entry point: initializes WebGL, wires up UI, and starts the render loop.
function main() {
    const canvas = document.getElementById("glcanvas"); // WebGL render surface
    const overlay = document.getElementById("overlay"); // 2D overlay for drag UI
    const gl = canvas.getContext("webgl");
    const ctx = overlay.getContext("2d");

    // Match canvas pixel sizes to the CSS-stretched viewport.
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    overlay.width = canvas.width;
    overlay.height = canvas.height;
    gl.viewport(0, 0, canvas.width, canvas.height);

    const vs = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSrc);
    const fs = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc);
    const prog = createProgram(gl, vs, fs);
    gl.useProgram(prog);

    // Cache attribute/uniform locations to avoid repeated lookups per frame.
    const aPos    = gl.getAttribLocation(prog, "a_position");
    const uCenter = gl.getUniformLocation(prog, "u_center");
    const uZoom   = gl.getUniformLocation(prog, "u_zoom");
    const uAspect = gl.getUniformLocation(prog, "u_aspect");
    const uRes    = gl.getUniformLocation(prog, "u_resolution");
    const uMaxIter = gl.getUniformLocation(prog, "u_maxIter");
    const uColorScale = gl.getUniformLocation(prog, "u_colorScale");
    const uSmoothColor = gl.getUniformLocation(prog, "u_smoothColor");
    const uPaletteOffset = gl.getUniformLocation(prog, "u_paletteOffset");
    //const uLogScale = gl.getUniformLocation(prog, "u_logScale");

    const screenAspect = canvas.width / canvas.height;
    const fractalAspect = 0.9; // Desired complex-plane width/height ratio

    let zoomY = 2.5;
    let zoomX = zoomY * fractalAspect;
    let currentCenter = { x:-0.375, y:0.0 }; // Start near the Seahorse Valley
    let currentZoom   = { x: zoomX,  y: zoomY };

    const initialArea = zoomX * zoomY;
    let currentMaxIter = 50; // Iteration count grows as the selected area shrinks

    let smooth = false; // Keyboard toggle for fractional iteration coloring
    //let logscale = false;

    gl.uniform2f(uRes, canvas.width, canvas.height); // Resolution sent once (until resize support is added)

    const getAspectCorrection = () => screenAspect * (currentZoom.y / currentZoom.x);
    const palettePeriod = 14.0; // Matches palette size in the fragment shader
    const paletteCycleRate = 2.0; // Palette indices per second
    let paletteOffset = 0.0;
    let lastFrameTime = 0;

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1,-1, 1,-1, -1,1,
        1,-1, 1,1, -1,1
    ]), gl.STATIC_DRAW); // Two triangles covering clip space
    gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aPos);

    function updateFractalUniforms(){
        const aspectCorrection = getAspectCorrection();
        const area = currentZoom.x * currentZoom.y;
        let colorScale = Math.sqrt(area / initialArea);
        colorScale = Math.max(colorScale, 0.05); // Prevent colors from going flat at deep zooms

        // Adjust shader parameters to reflect the latest zoom/center.
        gl.uniform1f(uAspect, aspectCorrection);
        gl.uniform2f(uCenter, currentCenter.x, currentCenter.y);
        gl.uniform2f(uZoom, currentZoom.x, currentZoom.y);
        gl.uniform1i(uMaxIter, currentMaxIter);
        gl.uniform1f(uColorScale, colorScale);
        gl.uniform1i(uSmoothColor, smooth ? 1 : 0);
        //gl.uniform1i(uLogScale, logscale ? 1 : 0);
    }

    updateFractalUniforms();

    function renderFrame(time){
        if(lastFrameTime === 0) lastFrameTime = time;
        const deltaSeconds = (time - lastFrameTime) / 1000;
        lastFrameTime = time;

        paletteOffset = (paletteOffset + deltaSeconds * paletteCycleRate) % palettePeriod;
        if(paletteOffset < 0) paletteOffset += palettePeriod;

        gl.uniform1f(uPaletteOffset, paletteOffset);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(renderFrame);
    }

    requestAnimationFrame(renderFrame);

    // --- Keyboard toggles ---
    document.addEventListener("keydown", e=>{
        if(e.key === "s") smooth = !smooth;
        //if(e.key === "l") logscale = !logscale;
        updateFractalUniforms();
    });

    // --- Rectangle selection for zooming ---
    let dragging = false;
    let start = {x:0,y:0};
    let curr = {x:0,y:0};
    // Record drag start position in overlay space.
    overlay.addEventListener("pointerdown", e=>{
        dragging = true;
        const r = overlay.getBoundingClientRect();
        start.x = e.clientX - r.left;
        start.y = e.clientY - r.top;
        curr = {...start};
    });

    // Update rectangle preview while dragging.
    overlay.addEventListener("pointermove", e=>{
        if(!dragging) return;
        const r = overlay.getBoundingClientRect();
        curr.x = e.clientX - r.left;
        curr.y = e.clientY - r.top;
        drawRect();
    });

    // Finish the selection when the pointer is released or leaves the canvas.
    overlay.addEventListener("pointerup", clearRect);
    overlay.addEventListener("pointerleave", clearRect);

    function drawRect(){
        // Render the drag rectangle preview, snapping to the current view aspect ratio.
        ctx.clearRect(0,0,overlay.width,overlay.height);
        let dx = curr.x - start.x;
        let dy = curr.y - start.y;
        if(Math.abs(dx) < 2 && Math.abs(dy) < 2) return;

        const adx = Math.abs(dx);
        const ady = Math.abs(dy);
        const targetAspect = currentZoom.x / currentZoom.y;

        let width, height;
        if(adx / Math.max(ady,1e-6) > targetAspect){
            width = dx;
            height = Math.sign(dy||1) * (adx/targetAspect);
        } else {
            height = dy;
            width = Math.sign(dx||1) * (ady*targetAspect);
        }

        let x = start.x, y = start.y;
        if(width < 0){x+=width; width=-width;}
        if(height<0){y+=height;height=-height;}

        ctx.strokeStyle="white";
        ctx.lineWidth=1;
        ctx.strokeRect(x,y,width,height);
    }

    function clearRect(){
        if(!dragging) return;
        dragging = false;
        let x1=start.x,y1=start.y;
        let x2=curr.x,y2=curr.y;
        if(x2<x1)[x1,x2]=[x2,x1];
        if(y2<y1)[y1,y2]=[y2,y1];
        ctx.clearRect(0,0,overlay.width,overlay.height);
        if(x2-x1<4||y2-y1<4)return; // Ignore tiny clicks (treated as taps)
        applyZoomFromRect(x1,y1,x2,y2);
    }

    function applyZoomFromRect(x1,y1,x2,y2){
        // Translate overlay pixel coordinates into complex plane bounds.
        function pixelToComplex(px,py){
            const uvx=(px/overlay.width)-0.5;
            const uvy=0.5-(py/overlay.height);
            const uvx2=uvx*getAspectCorrection();
            return {
                x: uvx2*currentZoom.x + currentCenter.x,
                y: uvy*currentZoom.y + currentCenter.y
            };
        }

        const c1=pixelToComplex(x1,y1);
        const c2=pixelToComplex(x2,y2);
        const minX=Math.min(c1.x,c2.x);
        const maxX=Math.max(c1.x,c2.x);
        const minY=Math.min(c1.y,c2.y);
        const maxY=Math.max(c1.y,c2.y);

        currentZoom.x=(maxX-minX);
        currentZoom.y=(maxY-minY);
        currentCenter.x=(minX+maxX)/2;
        currentCenter.y=(minY+maxY)/2;

        const area=currentZoom.x*currentZoom.y;
        const scale=Math.sqrt(initialArea/area);
        currentMaxIter=Math.min(2000,Math.max(50,Math.floor(50*scale)));

        updateFractalUniforms();
    }
}

main();
</script>
</body>
</html>
