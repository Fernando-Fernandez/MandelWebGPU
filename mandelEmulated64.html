<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Mandelbrot WebGL DS (emulated FP64)</title>
<style>
  body { margin: 0; }
  canvas { position:absolute; left:0; top:0; display:block; }
  #glcanvas { width:100vw; height:100vh; z-index:0; }
  #overlay { width:100vw; height:100vh; z-index:1; }
</style>
</head>
<body>

<canvas id="glcanvas"></canvas>
<canvas id="overlay"></canvas>

<script>
const vertexShaderSrc = `
attribute vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
}`;

// Fragment shader with double-single emulation
const fragmentShaderSrc = `
precision highp float;

// center.x = (hiRe, loRe), center.y = (hiIm, loIm)
uniform vec4 u_center64; // x=Re_hi, y=Re_lo, z=Im_hi, w=Im_lo
uniform vec4 u_zoom64;   // x=Re_hi, y=Re_lo, z=Im_hi, w=Im_lo

uniform vec2 u_resolution;
uniform float u_aspect;
uniform int u_maxIter;
uniform float u_colorScale;
uniform bool u_smoothColor;

const int MAX_ITER = 2000;
const float PALETTE_SIZE = 14.0;

// ----- double-single type and helpers -----
struct DS {
    float hi;
    float lo;
};

DS ds_make(float x) {
    DS r;
    r.hi = x;
    r.lo = 0.0;
    return r;
}

DS ds_make2(float hi, float lo) {
    DS r;
    r.hi = hi;
    r.lo = lo;
    return r;
}

// Dekker/Kahan style addition
DS ds_add(DS a, DS b) {
    float s = a.hi + b.hi;
    float v = s - a.hi;
    float t = ((b.hi - v) + (a.hi - (s - v))) + a.lo + b.lo;
    DS r;
    r.hi = s + t;
    r.lo = t - (r.hi - s);
    return r;
}

DS ds_sub(DS a, DS b) {
    DS nb;
    nb.hi = -b.hi;
    nb.lo = -b.lo;
    return ds_add(a, nb);
}

// double-single multiply
DS ds_mul(DS a, DS b) {
    const float SPLIT = 4097.0;
    float c11 = a.hi * b.hi;

    float cona = a.hi * SPLIT;
    float conb = b.hi * SPLIT;
    float a1 = cona - (cona - a.hi);
    float b1 = conb - (conb - b.hi);
    float a2 = a.hi - a1;
    float b2 = b.hi - b1;

    float c21 = ((a1 * b1 - c11) + a1 * b2 + a2 * b1) + a2 * b2;
    float c2 = a.hi * b.lo + a.lo * b.hi;
    float t = c21 + c2;
    float s = c11 + t;

    DS r;
    r.hi = s;
    r.lo = (c11 - s) + t + a.lo * b.lo;
    return r;
}

// palette as before (still uses float index)
vec3 palette(float idx) {
    float i = mod(idx, PALETTE_SIZE);
    if(i < 1.0) return vec3(0.5,0.5,0.5);
    if(i < 2.0) return vec3(0.0,0.0,0.0);
    if(i < 3.0) return vec3(0.6,0.4,0.2);
    if(i < 4.0) return vec3(1.0,0.0,0.0);
    if(i < 5.0) return vec3(1.0,0.5,0.0);
    if(i < 6.0) return vec3(1.0,1.0,0.0);
    if(i < 7.0) return vec3(0.0,1.0,0.0);
    if(i < 8.0) return vec3(0.5,1.0,0.83);
    if(i < 9.0) return vec3(0.0,1.0,1.0);
    if(i < 10.0) return vec3(0.0,0.0,1.0);
    if(i < 11.0) return vec3(0.0,0.0,0.5);
    if(i < 12.0) return vec3(0.5,0.0,0.5);
    if(i < 13.0) return vec3(1.0,0.0,1.0);
    return vec3(1.0,1.0,1.0);
}

void main() {
    vec2 uv = (gl_FragCoord.xy / u_resolution) - 0.5;
    uv.x *= u_aspect;

    // Build DS center/zoom
    DS centerRe = ds_make2(u_center64.x, u_center64.y);
    DS centerIm = ds_make2(u_center64.z, u_center64.w);
    DS zoomRe   = ds_make2(u_zoom64.x,   u_zoom64.y);
    DS zoomIm   = ds_make2(u_zoom64.z,   u_zoom64.w);

    // uv as DS
    DS uvRe = ds_make(uv.x);
    DS uvIm = ds_make(uv.y);

    // c = uv * zoom + center   (component-wise)
    DS cRe = ds_add(ds_mul(uvRe, zoomRe), centerRe);
    DS cIm = ds_add(ds_mul(uvIm, zoomIm), centerIm);

    // z in DS
    DS zRe = ds_make(0.0);
    DS zIm = ds_make(0.0);

    float i = 0.0;
    bool escaped = false;

    for(int n = 0; n < MAX_ITER; n++) {
        if(n >= u_maxIter) break;

        // z^2: (x + i y)^2 = (x^2 - y^2) + i(2xy)
        DS zRe2 = ds_mul(zRe, zRe);
        DS zIm2 = ds_mul(zIm, zIm);
        DS x2_minus_y2 = ds_sub(zRe2, zIm2);

        DS xy = ds_mul(zRe, zIm);
        DS two_xy;
        two_xy.hi = xy.hi * 2.0;
        two_xy.lo = xy.lo * 2.0;

        // z = z^2 + c
        zRe = ds_add(x2_minus_y2, cRe);
        zIm = ds_add(two_xy, cIm);

        // bailout using hi parts only
        float zr = zRe.hi;
        float zi = zIm.hi;
        if(zr*zr + zi*zi > 4.0) {
            i = float(n);
            escaped = true;
            break;
        }
        i = float(n);
    }

    if(!escaped) {
        gl_FragColor = vec4(0.0,0.0,0.0,1.0);
        return;
    }

    float val = i;

    if(u_smoothColor) {
        float zr = zRe.hi;
        float zi = zIm.hi;
        float mag = zr*zr + zi*zi;
        if(mag > 0.0) {
            val = val + 1.0 - log(log(mag)) / log(2.0);
        }
    }

    float scaled = val * u_colorScale;
    gl_FragColor = vec4(palette(scaled),1.0);
}
`;

function compileShader(gl, type, source) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(s));
    return s;
}

function createProgram(gl, vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS))
        console.error(gl.getProgramInfoLog(p));
    return p;
}

// split JS double -> hi/lo float (double-single)
function split64(x) {
    const hi = Math.fround(x);   // nearest float32
    const lo = x - hi;
    return { hi, lo };
}

function main() {
    const canvas = document.getElementById("glcanvas");
    const overlay = document.getElementById("overlay");
    const gl = canvas.getContext("webgl");
    const ctx = overlay.getContext("2d");

    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    overlay.width = canvas.width;
    overlay.height = canvas.height;
    gl.viewport(0, 0, canvas.width, canvas.height);

    const vs = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSrc);
    const fs = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc);
    const prog = createProgram(gl, vs, fs);
    gl.useProgram(prog);

    const aPos        = gl.getAttribLocation(prog, "a_position");
    const uCenter64   = gl.getUniformLocation(prog, "u_center64");
    const uZoom64     = gl.getUniformLocation(prog, "u_zoom64");
    const uAspect     = gl.getUniformLocation(prog, "u_aspect");
    const uRes        = gl.getUniformLocation(prog, "u_resolution");
    const uMaxIter    = gl.getUniformLocation(prog, "u_maxIter");
    const uColorScale = gl.getUniformLocation(prog, "u_colorScale");
    const uSmoothColor= gl.getUniformLocation(prog, "u_smoothColor");

    const fractalAspect = 0.9;
    const screenAspect = canvas.width / canvas.height;

    let zoomY = 2.5;
    let zoomX = zoomY * fractalAspect;
    let currentCenter = { x: -0.375, y: 0.0 };
    let currentZoom   = { x: zoomX,  y: zoomY };

    const initialArea = zoomX * zoomY;
    let currentMaxIter = 50;
    let smooth = false;

    gl.uniform1f(uAspect, screenAspect / fractalAspect);
    gl.uniform2f(uRes, canvas.width, canvas.height);

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1,-1, 1,-1, -1,1,
        1,-1, 1,1, -1,1
    ]), gl.STATIC_DRAW);
    gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aPos);

    function updateUniformsAndRedraw() {
        const area = currentZoom.x * currentZoom.y;
        let colorScale = Math.sqrt(area / initialArea);
        colorScale = Math.max(colorScale, 0.05);

        const cx = split64(currentCenter.x);
        const cy = split64(currentCenter.y);
        const zx = split64(currentZoom.x);
        const zy = split64(currentZoom.y);

        gl.uniform4f(uCenter64, cx.hi, cx.lo, cy.hi, cy.lo);
        gl.uniform4f(uZoom64,   zx.hi, zx.lo, zy.hi, zy.lo);
        gl.uniform1i(uMaxIter, currentMaxIter);
        gl.uniform1f(uColorScale, colorScale);
        gl.uniform1i(uSmoothColor, smooth ? 1 : 0);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    updateUniformsAndRedraw();

    // keyboard: toggle smooth coloring
    document.addEventListener("keydown", e => {
        if (e.key === "s") {
            smooth = !smooth;
            updateUniformsAndRedraw();
        }
    });

    // ---- rectangle selection (fixed aspect) ----
    let dragging = false;
    let start = {x:0,y:0};
    let curr  = {x:0,y:0};

    overlay.addEventListener("pointerdown", e => {
        dragging = true;
        const r = overlay.getBoundingClientRect();
        start.x = e.clientX - r.left;
        start.y = e.clientY - r.top;
        curr = {...start};
    });

    overlay.addEventListener("pointermove", e => {
        if(!dragging) return;
        const r = overlay.getBoundingClientRect();
        curr.x = e.clientX - r.left;
        curr.y = e.clientY - r.top;
        drawRect();
    });

    overlay.addEventListener("pointerup", clearRect);
    overlay.addEventListener("pointerleave", clearRect);

    const fractAspect = 0.9;

    function drawRect() {
        ctx.clearRect(0,0,overlay.width,overlay.height);
        let dx = curr.x - start.x;
        let dy = curr.y - start.y;
        if(Math.abs(dx) < 2 && Math.abs(dy) < 2) return;

        const adx = Math.abs(dx);
        const ady = Math.abs(dy);

        let width, height;
        if(adx / Math.max(ady,1e-6) > fractAspect){
            width = dx;
            height = Math.sign(dy||1) * (adx/fractalAspect);
        } else {
            height = dy;
            width = Math.sign(dx||1) * (ady*fractalAspect);
        }

        let x = start.x, y = start.y;
        if(width < 0){ x += width; width = -width; }
        if(height<0){ y += height; height = -height; }

        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.strokeRect(x,y,width,height);
    }

    function clearRect() {
        if(!dragging) return;
        dragging = false;
        let x1 = start.x, y1 = start.y;
        let x2 = curr.x,  y2 = curr.y;
        if(x2 < x1) [x1,x2] = [x2,x1];
        if(y2 < y1) [y1,y2] = [y2,y1];
        ctx.clearRect(0,0,overlay.width,overlay.height);
        if(x2 - x1 < 4 || y2 - y1 < 4) return;
        applyZoomFromRect(x1,y1,x2,y2);
    }

    function applyZoomFromRect(x1,y1,x2,y2) {
        function pixelToComplex(px,py) {
            const uvx = (px/overlay.width) - 0.5;
            const uvy = 0.5 - (py/overlay.height);
            const uvx2 = uvx * (screenAspect / fractalAspect);
            return {
                x: uvx2 * currentZoom.x + currentCenter.x,
                y: uvy  * currentZoom.y + currentCenter.y
            };
        }

        const c1 = pixelToComplex(x1,y1);
        const c2 = pixelToComplex(x2,y2);

        const minX = Math.min(c1.x,c2.x);
        const maxX = Math.max(c1.x,c2.x);
        const minY = Math.min(c1.y,c2.y);
        const maxY = Math.max(c1.y,c2.y);

        currentZoom.x = (maxX - minX);
        currentZoom.y = (maxY - minY);
        currentCenter.x = (minX + maxX)/2;
        currentCenter.y = (minY + maxY)/2;

        const area = currentZoom.x * currentZoom.y;
        const scale = Math.sqrt(initialArea / area);
        currentMaxIter = Math.min(2000, Math.max(50, Math.floor(50 * scale)));

        updateUniformsAndRedraw();
    }
}

main();
</script>
</body>
</html>
